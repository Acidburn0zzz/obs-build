#!/usr/bin/perl -w

################################################################
#
# Copyright (c) 1995-2014 SUSE Linux Products GmbH
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 2 or 3 as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program (see the file COPYING); if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA
#
################################################################

BEGIN {
  unshift @INC, ($::ENV{'BUILD_DIR'} || '/usr/lib/build');
}

use strict;
use Data::Dumper;
use Getopt::Long;
use Build::Rpm;
use Build::Rpmmd;
use Digest::MD5 qw(md5 md5_hex md5_base64);
use File::Path qw(mkpath rmtree);
use File::Basename;
use LWP::UserAgent;
use URI;

Getopt::Long::Configure("no_ignore_case");

my $opt_dump;
my $opt_old;
my $opt_nosrc;
my $opt_bc;
my $opt_zypp;
my $cachedir = "/var/cache/build";

my $baseurl; # current url
my $old_seen;
my @packages;

sub package_parsed {
  my ($pkg) = @_;

  $pkg->{'baseurl'} = $baseurl;
  push @packages, $pkg if $opt_dump;
  if($opt_bc) {
    return if $pkg->{'arch'} eq 'src' || $pkg->{'arch'} eq 'nosrc';
    my $id = sprintf("%s.%s-%d/%d/%d: ", $pkg->{'name'}, $pkg->{'arch'}, $pkg->{'buildtime'}, $pkg->{'filetime'}, 0);
    print "F:".$id. $pkg->{'baseurl'} . $pkg->{'location'} . "\n";
    print "P:$id@{$pkg->{'provides'} || []}\n";
    print "R:$id@{$pkg->{'requires'} || []}\n";
    print "C:$id@{$pkg->{'conflicts'} || []}\n" if @{$pkg->{'conflicts'} || []};
    print "O:$id@{$pkg->{'obsoletes'} || []}\n" if @{$pkg->{'obsoletes'} || []};
    my $tag = sprintf("%s-%s-%s %s", $pkg->{'name'}, $pkg->{'version'}, $pkg->{'release'}, $pkg->{'buildtime'});
    print "I:$id$tag\n";
  } elsif ($opt_old) {
    my $arch = $pkg->{'arch'};
    $arch = 'src' if $pkg->{'arch'} eq 'nosrc';
    return if $arch eq 'src' && $opt_nosrc;
    my $evr = $pkg->{'version'}.'-'.$pkg->{'release'};
    $evr = "$pkg->{'epoch'}:$evr" if $pkg->{'epoch'};
    if (exists($old_seen->{$pkg->{'name'}}->{$arch})) {
      my $vv = Build::Rpm::verscmp($old_seen->{$pkg->{'name'}}->{$arch}->{'evr'}, $evr, 0);
      if ($vv < 0) {
	print $old_seen->{$pkg->{'name'}}->{$arch}->{'loc'}."\n";
	$old_seen->{$pkg->{'name'}}->{$arch}->{'evr'} = $evr;
	$old_seen->{$pkg->{'name'}}->{$arch}->{'loc'} = $pkg->{'baseurl'} . $pkg->{'location'};
      } else {
	print $pkg->{'baseurl'} . $pkg->{'location'}."\n";
      }
    } else {
      $old_seen->{$pkg->{'name'}}->{$arch}->{'evr'} = $evr;
      $old_seen->{$pkg->{'name'}}->{$arch}->{'loc'} = $pkg->{'baseurl'} . $pkg->{'location'};
    }
  }
}

sub printasbuildcachefile(@) {
}

sub getmetadata {
  my ($url, $dir) = @_;
  my $dest = "${dir}repodata";
  mkpath($dest);
  system($INC[0].'/download', $dest, "${url}repodata/repomd.xml");
}

### main

GetOptions (
    "nosrc"   => \$opt_nosrc,
    "dump"   => \$opt_dump,
    "old"   => \$opt_old,
    "zypp=s"   => \$opt_zypp,
    "cachedir=s"  => \$cachedir,
    ) or exit(1);

$opt_bc = 1 unless $opt_dump || $opt_old;

#my $url = '/mounts/mirror/SuSE/ftp.suse.com/pub/suse/update/10.1/';

for my $url (@ARGV) {
  my $dir;
  if ($opt_zypp) {
    $dir = $opt_zypp;
    $dir .= '/' unless $dir =~ /\/$/;
    $baseurl = $url;
    $baseurl .= '/' unless $baseurl =~ /\/$/;
  } elsif ($url =~ /^(?:ftps?|https?):\/\/([^\/]*)\/?/) {
    my $repoid = md5_hex($url);
    $dir = "$cachedir/$repoid/";
    $baseurl = $url;
    $baseurl .= '/' unless $baseurl =~ /\/$/;
    getmetadata($baseurl, $dir);
  } else {
    $dir = $url;
    $dir .= '/' unless $dir =~ /\/$/;
    $baseurl = $dir;
  }

  die("zypp repo $url is not up to date, please refresh first\n") unless -s "${dir}repodata/repomd.xml";

  my @primaryfiles;
  my $repomdfh;
  open($repomdfh, '<', "${dir}repodata/repomd.xml") || die("${dir}repodata/repomd.xml: $!\n");
  Build::Rpmmd::parse_repomd($repomdfh, \@primaryfiles);
  close($repomdfh);
  @primaryfiles = grep {$_->{'type'} eq 'primary' && defined($_->{'location'})} @primaryfiles;

#  print Dumper(\@primaryfiles);

  for my $f (@primaryfiles) {
    my $u = "$dir$f->{'location'}";
    if ($] > 5.007) {
	require Encode;
	utf8::downgrade($u);
    }
    my $cached;
    if (-e $u) {
      $cached = 1;
      $cached = 0 if exists($f->{'size'}) && $f->{'size'} != (-s _);
      $cached = 0 if !exists($f->{'size'}) && $u !~ /[0-9a-f]{32}-primary/;
    }
    if (!$cached) {
	die("zypp repo $url is not up to date, please refresh first\n") if $opt_zypp;
	if ($url =~ /^(?:ftps?|https?):\/\/([^\/]*)\/?/) {
	    if (system($INC[0].'/download', $dir . "repodata/", $baseurl . "repodata/" . basename($u))) {
	      die("download failed\n");
	    }
	} else {
	    die("inconsistent repodata in $url\n");
	}
    }
    my $fh;
    open($fh, '<', $u) or die "Error opening $u: $!\n";
    if ($u =~ /\.gz$/) {
	use IO::Uncompress::Gunzip qw($GunzipError);
	$fh = new IO::Uncompress::Gunzip $fh or die "Error opening $u: $GunzipError\n";
    }
    Build::Rpmmd::parse_primary($fh, \&package_parsed);
    close($fh);
  }
}

if ($opt_dump) {
    print Data::Dumper->Dump([\@packages], ['packages']); # caution: excessive memory consumption!
}

